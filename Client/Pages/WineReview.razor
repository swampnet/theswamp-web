@page "/wine/{id:long?}"

@using TheSwamp.Shared
@using System.Threading;

@inject HttpClient _http
@inject NavigationManager _navigationManager

<div class="wine-review">
    @if (_wine == null)
    {
        <div class="busy" />
    }
    else
    {
        <div>
            <h3>@_wine.Name</h3>
            <h4>@_wine.ProducerName, @_wine.Region, @_wine.Country</h4>
        </div>
    }

    <div class="review">
        @if (!string.IsNullOrEmpty(_streamResponse))
        {
            <span class="oi oi-double-quote-serif-left" aria-hidden="true"></span>
            <span>&nbsp;</span>
        }

        @((MarkupString)_streamResponse)

        @if (!_isLoadingWine && !_isReviewing)
        {
            <span>&nbsp;</span>
            <span class="oi oi-double-quote-serif-right" aria-hidden="true"></span>
        }

        @if(_isReviewing)
        {
            <div class="busy" />
        }
    </div>

    @if (!_isLoadingWine && !_isReviewing)
    {
        <div class="options">
            <select @bind-value="_personality" @bind-value:event="oninput" @onchange="Review" class="form-control" style="width:200px;display:inline">
                @foreach (var x in Enum.GetNames<ReviewPersonality>())
                {
                    <option value="@x">@x</option>
                }
            </select>

            <button @onclick="Refresh" class="btn btn-primary"><span class="oi oi-reload"> Another...</span></button>
        </div>
    }

    @if (!_isLoadingWine && !_isReviewing)
    {
        <hr />
        <div class="disclaimer">
            Generated by an <a href="https://beta.openai.com/" title="GPT-3">AI</a>. Opinions are its own and generally pretty random. Please don't sue me.
        </div>
    }
</div>

<div class="error">
    @foreach(var error in _errors)
    {
        <div>@error.Message</div>
    }
</div>

<div class="dev">
    <div>Loading: @_isLoadingWine</div>
    <div>Reviewing: @_isReviewing</div>
    <div>Personality: @_personality</div>
    @if (_wine != null)
    {
        <table width="100%" style="margin-top:10px">
            <thead>
                <tr>
                    <th>Id</th>
                    <th>Name</th>
                    <th>Type</th>
                    <th>Sub Type</th>
                    <th>Colour</th>
                    <th>ProducerName</th>
                    <th>Country</th>
                    <th>Region</th>
                    <th>Sub Region</th>
                    <th>Vintage</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><a href="/wine/@_wine.Id">@_wine.Id</a></td>
                    <td>@_wine.Name</td>
                    <td>@_wine.Type</td>
                    <td>@_wine.SubType</td>
                    <td>@_wine.Colour</td>
                    <td>@_wine.ProducerName</td>
                    <td>@_wine.Country</td>
                    <td>@_wine.Region</td>
                    <td>@_wine.SubRegion</td>
                    <td>@_wine.Vintage</td>
                </tr>
            </tbody>
        </table>
    }
</div>

@code {
    [Parameter]
    public long? Id { get; set; }

    private List<Exception> _errors = new List<Exception>();
    private bool _isLoadingWine = false;
    private bool _isReviewing = false;

    private string _streamResponse;
    private CancellationTokenSource _cts;
    private Wine _wine = null;
    private ReviewPersonality _personality;

    protected override async Task OnInitializedAsync()
    {
        _errors.Clear();

        await Refresh();
    }


    private async Task Refresh()
    {
        try
        {
            _wine = null;
            _streamResponse = "";

            _wine = await LoadWineAsync(Id);
            await Review();
        }
        catch(Exception ex)
        {
            _errors.Add(ex);
        }
        finally
        {
        }
    }

    private async Task<Wine> LoadWineAsync(long? id = null)
    {
        _isLoadingWine = true;

        try
        {
            return await _http.GetFromJsonAsync<Wine>("/api/wine/" + (id.HasValue ? id.Value.ToString() : "random"));
        }
        catch (Exception ex)
        {
            _errors.Add(ex);
        }
        finally
        {
            _isLoadingWine = false;
        }

        return null;
    }


    private async Task Review()
    {
        _isReviewing = true;
        try
        {
            _streamResponse = "";
            _cts = new CancellationTokenSource();
            var url = $"/api/wine/{_wine.Id}/review?p={_personality}";
            using var request = new HttpRequestMessage(HttpMethod.Get, url);

            request.SetBrowserResponseStreamingEnabled(true); // Enable response streaming

            // Be sure to use HttpCompletionOption.ResponseHeadersRead
            using var response = await _http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
            using var stream = await response.Content.ReadAsStreamAsync();

            // Read the response chunk by chunk and count the number of bytes
            var bytes = new byte[10];

            while (!_cts.Token.IsCancellationRequested)
            {
                Array.Clear(bytes, 0, bytes.Length);

                var read = await stream.ReadAsync(bytes, _cts.Token);
                // End of stream
                if (read == 0)
                {
                    return;
                }

                var s = System.Text.Encoding.Default.GetString(bytes.Where(x => x != 0).ToArray());

                // Replace newlines in response breaks
                _streamResponse = (_streamResponse + s).Replace("\n", "<br/>");

                // Update the UI
                StateHasChanged();

                await Task.Delay(1);
            }
        }
        catch (Exception ex)
        {
            _errors.Add(ex);
        }
        finally
        {
            _isReviewing = false;
        }
    }

    // Cancel the request
    void Stop()
    {
        _cts?.Cancel();
    }
}
