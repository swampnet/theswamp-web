@page "/wine"

@using TheSwamp.Shared
@using System.Threading;

@inject HttpClient _http
@inject NavigationManager _navigationManager

<div class="wine-review">
    @if(_wine == null)
    {
        <div class="busy" />
    }
    else
    {
        <div>
            <h3>@_wine.Name</h3>
            <h4>@_wine.ProducerName, @_wine.Region, @_wine.Country</h4>
        </div>
    }

    <p class="review">
        @if(!string.IsNullOrEmpty(_streamResponse))
        {
            <span class="oi oi-double-quote-serif-left" aria-hidden="true"></span>
        }

        @((MarkupString)_streamResponse)

        @if (!_isBusy)
        {
            <span class="oi oi-double-quote-serif-right" aria-hidden="true"></span>
        }
    </p>

    @if (!_isBusy)
    {
        <button @onclick="Refresh"><span class="oi oi-reload"> Another...</span></button>
    }

    @code {
        private bool _isBusy = true;
        private int _byteCount;
        private string _streamResponse;
        private CancellationTokenSource _cts;
        private Wine _wine = null;

        protected override async Task OnInitializedAsync()
        {
            await Refresh();
        }

        private async Task Refresh()
        {
            try
            {
                _isBusy = true;
                _wine = null;
                _streamResponse = "";
                _byteCount = 0;

                _wine = await LoadWineAsync();
                await Review(_wine.Id);
            }
            catch
            {

            }
            finally
            {
                _isBusy = false;
            }
        }

        private Task<Wine> LoadWineAsync(long? id = null)
        {
            return _http.GetFromJsonAsync<Wine>("/api/wine/" + (id.HasValue?id.Value.ToString():"random"));
        }

        async Task Review(long id)
        {
            _cts = new CancellationTokenSource();

            using var request = new HttpRequestMessage(HttpMethod.Get, $"/api/wine/{id}/review");

            request.SetBrowserResponseStreamingEnabled(true); // Enable response streaming

            // Be sure to use HttpCompletionOption.ResponseHeadersRead
            using var response = await _http.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);
            using var stream = await response.Content.ReadAsStreamAsync();

            // Read the response chunk by chunk and count the number of bytes
            var bytes = new byte[10];
            _byteCount = 0;
            while (!_cts.Token.IsCancellationRequested)
            {
                Array.Clear(bytes, 0, bytes.Length);

                var read = await stream.ReadAsync(bytes, _cts.Token);
                // End of stream
                if (read == 0)
                {
                    return;
                }

                _byteCount += read;

                var s = System.Text.Encoding.Default.GetString(bytes.Where(x => x != 0).ToArray());

                // Replace newlines in response breaks
                _streamResponse = (_streamResponse + s).Replace("\n", "<br/>");

                // Update the UI
                StateHasChanged();

                await Task.Delay(1);
            }
        }

        // Cancel the request
        void Stop()
        {
            _cts?.Cancel();
        }
    }
</div>
